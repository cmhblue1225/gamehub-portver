<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mountain Marble Maze - 3D ì„¼ì„œ ê²Œì„</title>

    <!-- Socket.IO -->
    <script src="/socket.io/socket.io.js"></script>

    <!-- QR Code -->
    <script src="https://unpkg.com/qrcode@1.5.3/build/qrcode.min.js"></script>

    <!-- SessionSDK -->
    <script src="/js/SessionSDK.js"></script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

    <!-- Cannon.js (ë¬¼ë¦¬ ì—”ì§„) -->
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', 'Malgun Gothic', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
            background: linear-gradient(180deg, #87CEEB 0%, #E0F6FF 50%, #90EE90 100%);
        }

        /* UI ì˜¤ë²„ë ˆì´ */
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .ui-overlay > * {
            pointer-events: auto;
        }

        /* ìƒë‹¨ HUD */
        .top-hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .hud-item {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            margin: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .hud-time {
            background: rgba(255, 100, 100, 0.9);
        }

        .hud-score {
            background: rgba(255, 215, 0, 0.9);
            color: #333;
        }

        .hud-distance {
            background: rgba(76, 175, 80, 0.9);
        }

        /* í•˜ë‹¨ ì•„ì´í…œ ìƒíƒœ */
        .bottom-hud {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 15px;
        }

        .item-count {
            color: #fff;
            font-size: 24px;
            font-weight: bold;
        }

        .item-count .icon {
            margin-right: 5px;
        }

        /* ì†ë„ê³„ */
        .speed-meter {
            position: absolute;
            top: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 12px;
            color: #4ECDC4;
            font-size: 20px;
            font-weight: bold;
            border: 2px solid #4ECDC4;
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
        }

        .speed-meter .label {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 5px;
        }

        .speed-value {
            font-size: 28px;
            color: #4ECDC4;
            text-shadow: 0 0 10px #4ECDC4;
        }

        /* ê¸°ìš¸ê¸° ì¸ë””ì¼€ì´í„° */
        .tilt-indicator {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 120px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0,0,0,0.7), rgba(0,0,0,0.9));
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .tilt-dot {
            position: absolute;
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #4CAF50, #8BC34A);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px #4CAF50, 0 0 40px #4CAF50;
            transition: all 0.1s ease-out;
        }

        .tilt-center {
            position: absolute;
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* ë©”ë‰´ í™”ë©´ */
        .menu-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .menu-screen.hidden {
            display: none;
        }

        .menu-title {
            font-size: 64px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.5);
            margin-bottom: 20px;
            animation: bounce 1s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .menu-subtitle {
            font-size: 24px;
            color: #fff;
            margin-bottom: 40px;
            text-align: center;
            padding: 0 20px;
        }

        .start-btn {
            padding: 20px 60px;
            font-size: 28px;
            font-weight: bold;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 30px;
        }

        .start-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 30px rgba(76, 175, 80, 0.5);
        }

        /* QR ì½”ë“œ ì»¨í…Œì´ë„ˆ */
        .qr-container {
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            text-align: center;
            display: none;
        }

        .qr-container.show {
            display: block;
        }

        .qr-title {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
        }

        .session-code {
            font-size: 32px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 15px;
            letter-spacing: 5px;
        }

        /* ê²°ê³¼ í™”ë©´ */
        .result-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
        }

        .result-screen.show {
            display: flex;
        }

        .result-title {
            font-size: 64px;
            font-weight: bold;
            color: #FF6B6B;
            margin-bottom: 20px;
        }

        .survival-time {
            font-size: 48px;
            color: #4ECDC4;
            margin-bottom: 30px;
        }

        .final-score {
            font-size: 56px;
            color: #FFD700;
            margin-bottom: 20px;
        }

        .score-breakdown {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            width: 100%;
            max-width: 500px;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            color: #fff;
            font-size: 20px;
            margin: 10px 0;
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .ranking-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            width: 100%;
            max-width: 600px;
        }

        .ranking-title {
            font-size: 32px;
            color: #FFD700;
            margin-bottom: 15px;
            text-align: center;
        }

        .ranking-list {
            color: #fff;
        }

        .ranking-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-size: 18px;
        }

        .ranking-item.me {
            background: rgba(76, 175, 80, 0.3);
            border: 2px solid #4CAF50;
        }

        .rank-number {
            font-weight: bold;
            color: #FFD700;
            min-width: 40px;
        }

        .restart-btn {
            padding: 20px 60px;
            font-size: 28px;
            font-weight: bold;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .restart-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 30px rgba(76, 175, 80, 0.5);
        }

        /* í”¼ë“œë°± í…ìŠ¤íŠ¸ */
        .feedback-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
            animation: fadeOut 1s;
            pointer-events: none;
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        /* ì¹´ìš´íŠ¸ë‹¤ìš´ */
        .countdown {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 5px 5px 10px rgba(0,0,0,0.5);
            z-index: 500;
            animation: pulse 0.5s;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>
    <!-- ë©”ë‰´ í™”ë©´ -->
    <div class="menu-screen" id="menuScreen">
        <div class="menu-title">ğŸ”ï¸ Mountain Marble Maze</div>
        <div class="menu-subtitle">
            ê¸°ìš¸ì—¬ì„œ ì¡°ì‘í•˜ëŠ” 3D ë¬´í•œ ìƒì¡´ ê²Œì„!<br>
            ì¥ì• ë¬¼ì„ í”¼í•˜ê³  ì•„ì´í…œì„ ìˆ˜ì§‘í•˜ì„¸ìš”
        </div>

        <button class="start-btn" onclick="game.init()">ğŸ® ê²Œì„ ì‹œì‘</button>

        <div class="qr-container" id="qrContainer">
            <div class="qr-title">ğŸ“± í•¸ë“œí°ìœ¼ë¡œ QR ì½”ë“œë¥¼ ìŠ¤ìº”í•˜ì„¸ìš”</div>
            <div class="session-code" id="sessionCode">------</div>
            <div id="qrCode"></div>
            <div style="margin-top: 20px; color: #666;">
                ì„¼ì„œê°€ ì—°ê²°ë˜ë©´ ìë™ìœ¼ë¡œ ê²Œì„ì´ ì‹œì‘ë©ë‹ˆë‹¤
            </div>
        </div>
    </div>

    <!-- ê²Œì„ ìº”ë²„ìŠ¤ -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI ì˜¤ë²„ë ˆì´ -->
    <div class="ui-overlay">
        <div class="top-hud">
            <div class="hud-item hud-time">â±ï¸ <span id="timeText">0.0</span>ì´ˆ</div>
            <div class="hud-item hud-score">ğŸ† <span id="scoreText">0</span>ì </div>
            <div class="hud-item hud-distance">ğŸ“ <span id="distanceText">0</span>m</div>
        </div>

        <!-- ì†ë„ê³„ -->
        <div class="speed-meter">
            <div class="label">ì†ë„</div>
            <div class="speed-value"><span id="speedText">0</span> m/s</div>
        </div>

        <!-- ê¸°ìš¸ê¸° ì¸ë””ì¼€ì´í„° -->
        <div class="tilt-indicator">
            <div class="tilt-center"></div>
            <div class="tilt-dot" id="tiltDot"></div>
        </div>

        <div class="bottom-hud">
            <div class="item-count">
                <span class="icon">â­</span>
                <span id="starsText">0</span>
            </div>
            <div class="item-count">
                <span class="icon">ğŸ’°</span>
                <span id="coinsText">0</span>
            </div>
        </div>
    </div>

    <!-- ê²°ê³¼ í™”ë©´ -->
    <div class="result-screen" id="resultScreen">
        <div class="result-title">Game Over!</div>
        <div class="survival-time">ìƒì¡´ ì‹œê°„: <span id="finalTime">0</span>ì´ˆ</div>
        <div class="final-score">ìµœì¢… ì ìˆ˜: <span id="finalScore">0</span>ì </div>

        <div class="score-breakdown">
            <div class="score-item">
                <span>ìƒì¡´ ì‹œê°„</span>
                <span id="timeBonus">0ì </span>
            </div>
            <div class="score-item">
                <span>ì´ë™ ê±°ë¦¬</span>
                <span id="distanceBonus">0ì </span>
            </div>
            <div class="score-item">
                <span>â­ ë³„ ìˆ˜ì§‘</span>
                <span id="starBonus">0ì </span>
            </div>
            <div class="score-item">
                <span>ğŸ’° ì½”ì¸ ìˆ˜ì§‘</span>
                <span id="coinBonus">0ì </span>
            </div>
        </div>

        <div class="ranking-section">
            <div class="ranking-title">ğŸ† Top 10 Ranking</div>
            <div class="ranking-list" id="rankingList"></div>
        </div>

        <button class="restart-btn" onclick="game.restart()">ğŸ”„ ë‹¤ì‹œ í•˜ê¸°</button>
    </div>

    <script>
        // ===== ë©”ì¸ ê²Œì„ í´ë˜ìŠ¤ =====
        class MountainMarbleMaze {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                // SDK ì´ˆê¸°í™”
                this.sdk = new SessionSDK({
                    gameId: 'mountain-marble-maze',
                    gameType: 'solo',
                    debug: true
                });

                // ê²Œì„ ìƒíƒœ
                this.state = {
                    connected: false,
                    playing: false,
                    paused: false,
                    survivalTime: 0,
                    score: 0,
                    distance: 0,
                    starsCollected: 0,
                    coinsCollected: 0,
                    speed: 5,  // ì§„í–‰ ì†ë„
                    startTime: 0
                };

                // 3D ì‹œìŠ¤í…œ
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.clock = new THREE.Clock();

                // ë¬¼ë¦¬ ì‹œìŠ¤í…œ
                this.world = null;
                this.ballBody = null;
                this.ballMesh = null;

                // ì§€í˜• ì‹œìŠ¤í…œ
                this.terrainGenerator = null;
                this.chunks = [];
                this.obstacles = [];
                this.items = [];

                // 3D ëª¨ë¸
                this.models = {
                    marble: null,
                    terrainTiles: null,
                    obstacles: null,
                    collectibles: null
                };

                // ì„¼ì„œ ë°ì´í„°
                this.sensorData = null;
                this.forceMultiplier = 60;  // 30 â†’ 60 (2ë°° ë°˜ì‘ì„±)

                // ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ëŸ¬
                window.addEventListener('resize', () => this.onResize());
            }

            async init() {
                console.log('ğŸ® ê²Œì„ ì´ˆê¸°í™” ì‹œì‘...');

                // SDK ì´ë²¤íŠ¸ ì„¤ì •
                this.setupSDK();

                // 3D ì´ˆê¸°í™”
                this.init3D();

                // ë¬¼ë¦¬ ì´ˆê¸°í™”
                this.initPhysics();

                // 3D ëª¨ë¸ ë¡œë”©
                await this.loadModels();

                // QR ì»¨í…Œì´ë„ˆ í‘œì‹œ
                document.getElementById('qrContainer').classList.add('show');

                // ì„¸ì…˜ ìƒì„±
                await this.sdk.createSession();
            }

            setupSDK() {
                // ì„œë²„ ì—°ê²°
                this.sdk.on('connected', () => {
                    console.log('âœ… ì„œë²„ ì—°ê²° ì™„ë£Œ');
                    this.state.connected = true;
                });

                // ì„¸ì…˜ ìƒì„±
                this.sdk.on('session-created', (event) => {
                    const session = event.detail || event;
                    console.log('âœ… ì„¸ì…˜ ìƒì„±:', session.sessionCode);

                    document.getElementById('sessionCode').textContent = session.sessionCode;

                    // QR ì½”ë“œ ìƒì„±
                    const sensorUrl = `${window.location.origin}/sensor.html?session=${session.sessionCode}`;
                    QRCodeGenerator.generateElement(sensorUrl, 200)
                        .then(qrElement => {
                            const container = document.getElementById('qrCode');
                            container.innerHTML = '';
                            container.appendChild(qrElement);
                        })
                        .catch(err => {
                            console.error('QR ì½”ë“œ ìƒì„± ì‹¤íŒ¨:', err);
                        });
                });

                // ì„¼ì„œ ì—°ê²°
                this.sdk.on('sensor-connected', (event) => {
                    console.log('ğŸ“± ì„¼ì„œ ì—°ê²°ë¨');
                    setTimeout(() => this.startGame(), 1000);
                });

                // ì„¼ì„œ ë°ì´í„° ìˆ˜ì‹ 
                this.sdk.on('sensor-data', (event) => {
                    const data = event.detail || event;
                    this.processSensorData(data);
                });
            }

            processSensorData(sensorData) {
                if (!sensorData || !sensorData.data || !this.state.playing) return;

                this.sensorData = sensorData.data;

                // ê¸°ìš¸ê¸° â†’ ë¬¼ë¦¬ë ¥ ë³€í™˜ (ê°œì„ )
                if (this.sensorData.orientation && this.ballBody) {
                    const gamma = this.sensorData.orientation.gamma || 0;  // ì¢Œìš°
                    const beta = this.sensorData.orientation.beta || 0;    // ì „í›„

                    // ë°ë“œì¡´ ì¶”ê°€ (ë¯¸ì„¸í•œ í”ë“¤ë¦¼ ë¬´ì‹œ)
                    const deadzone = 3;
                    const gammaFiltered = Math.abs(gamma) < deadzone ? 0 : gamma;
                    const betaFiltered = Math.abs(beta) < deadzone ? 0 : beta;

                    // ê°ë„ â†’ í˜ (ì‚¼ê°í•¨ìˆ˜)
                    const forceX = Math.sin(gammaFiltered * Math.PI / 180) * this.forceMultiplier;
                    const forceZ = Math.sin(betaFiltered * Math.PI / 180) * this.forceMultiplier;

                    // ë¬¼ë¦¬ ì—”ì§„ì— í˜ ì ìš©
                    const force = new CANNON.Vec3(forceX, 0, forceZ);
                    this.ballBody.applyForce(force, this.ballBody.position);
                }
            }

            // ===== 3D ì‹œìŠ¤í…œ =====

            init3D() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

                // Camera (3ì¸ì¹­ ì¶”ì )
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 5, 10);
                this.camera.lookAt(0, 0, 0);

                // Renderer
                // ë Œë”ëŸ¬ ê³ ê¸‰ ì„¤ì •
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    antialias: true,
                    powerPreference: 'high-performance',
                    alpha: false,
                    stencil: false
                });
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setSize(window.innerWidth, window.innerHeight);

                // í†¤ë§¤í•‘ (í˜„ì‹¤ì  ìƒ‰ê°)
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.2;
                this.renderer.outputEncoding = THREE.sRGBEncoding;

                // ê·¸ë¦¼ì í’ˆì§ˆ í–¥ìƒ
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.shadowMap.autoUpdate = true;

                // ì¡°ëª… ì‹œìŠ¤í…œ ì—…ê·¸ë ˆì´ë“œ
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);

                // êµ¬ìŠ¬ ì¶”ì  DirectionalLight
                this.directionalLight = new THREE.DirectionalLight(0xFFFFAA, 1.2);
                this.directionalLight.position.set(10, 20, 10);
                this.directionalLight.castShadow = true;

                // ê·¸ë¦¼ì í’ˆì§ˆ 4K
                this.directionalLight.shadow.mapSize.width = 4096;
                this.directionalLight.shadow.mapSize.height = 4096;
                this.directionalLight.shadow.camera.near = 0.1;
                this.directionalLight.shadow.camera.far = 150;
                this.directionalLight.shadow.camera.left = -30;
                this.directionalLight.shadow.camera.right = 30;
                this.directionalLight.shadow.camera.top = 30;
                this.directionalLight.shadow.camera.bottom = -30;
                this.directionalLight.shadow.bias = -0.0001;
                this.directionalLight.shadow.radius = 2;

                this.scene.add(this.directionalLight);

                // HemisphereLight ìƒ‰ìƒ ê°œì„ 
                const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x5A8F5A, 0.8);
                this.scene.add(hemisphereLight);

                // PointLight (êµ¬ìŠ¬ ì£¼ë³€ ê°•ì¡°)
                this.ballLight = new THREE.PointLight(0xFFFFFF, 0.5, 5);
                this.scene.add(this.ballLight);

                console.log('âœ… 3D ì—”ì§„ ì´ˆê¸°í™” ì™„ë£Œ');
            }

            initPhysics() {
                // Cannon.js ì›”ë“œ (ê³ ê¸‰ ì„¤ì •)
                this.world = new CANNON.World();
                this.world.gravity.set(0, -12, 0);  // -9.82 â†’ -12 (ë” ë¹ ë¥¸ ë‚™í•˜)
                this.world.broadphase = new CANNON.SAPBroadphase(this.world);  // ì„±ëŠ¥ ê°œì„ 
                this.world.solver.iterations = 15;  // 10 â†’ 15 (ë” ì •í™•í•œ ë¬¼ë¦¬)
                this.world.defaultContactMaterial.contactEquationStiffness = 1e8;
                this.world.defaultContactMaterial.contactEquationRelaxation = 3;

                // ì¬ì§ˆ
                const ballMaterial = new CANNON.Material('ball');
                const groundMaterial = new CANNON.Material('ground');

                const contactMaterial = new CANNON.ContactMaterial(
                    ballMaterial,
                    groundMaterial,
                    {
                        friction: 0.4,           // 0.3 â†’ 0.4 (ë” ì •í™•í•œ ì œì–´)
                        restitution: 0.4,        // 0.6 â†’ 0.4 (ëœ íŠ•ê¹€)
                        contactEquationStiffness: 1e8,
                        contactEquationRelaxation: 3
                    }
                );
                this.world.addContactMaterial(contactMaterial);

                // êµ¬ìŠ¬ ë¬¼ë¦¬ ë°”ë””
                const ballShape = new CANNON.Sphere(0.5);
                this.ballBody = new CANNON.Body({
                    mass: 1.2,  // 1 â†’ 1.2 (ë” ë¬´ê±°ìš´ ëŠë‚Œ)
                    shape: ballShape,
                    material: ballMaterial,
                    position: new CANNON.Vec3(0, 2, 0),
                    linearDamping: 0.2,   // 0.3 â†’ 0.2 (ë” ë°˜ì‘ì )
                    angularDamping: 0.2   // 0.3 â†’ 0.2
                });
                this.world.addBody(this.ballBody);

                console.log('âœ… ë¬¼ë¦¬ ì—”ì§„ ì´ˆê¸°í™” ì™„ë£Œ (ê³ ê¸‰ ì„¤ì •)');
            }

            async loadModels() {
                const loader = new THREE.GLTFLoader();

                // DRACOLoader ì„¤ì •
                const dracoLoader = new THREE.DRACOLoader();
                dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
                loader.setDRACOLoader(dracoLoader);

                console.log('ğŸ“¦ 3D ëª¨ë¸ ë¡œë”© ì¤‘...');

                try {
                    // ê³ í’ˆì§ˆ êµ¬ìŠ¬ (Hyper3D)
                    const marble = await this.loadModel(loader, 'assets/models/marble-ball-hd.glb');
                    marble.scale.set(1, 1, 1);
                    marble.castShadow = true;
                    marble.receiveShadow = true;

                    // ì¬ì§ˆ ì—…ê·¸ë ˆì´ë“œ
                    marble.traverse((child) => {
                        if (child.isMesh) {
                            child.material.metalness = 0.9;
                            child.material.roughness = 0.1;
                            child.material.envMapIntensity = 1.5;
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    this.scene.add(marble);
                    this.ballMesh = marble;
                    this.models.marble = marble;

                    // ì§€í˜• íƒ€ì¼ (ë‚˜ì¤‘ì— ì‚¬ìš©)
                    this.models.terrainTiles = await this.loadModel(loader, 'assets/models/terrain-tiles.glb');
                    this.models.terrainTiles.visible = false;

                    // ì¥ì• ë¬¼
                    this.models.obstacles = await this.loadModel(loader, 'assets/models/obstacles.glb');
                    this.models.obstacles.visible = false;

                    // ì•„ì´í…œ
                    this.models.collectibles = await this.loadModel(loader, 'assets/models/collectibles.glb');
                    this.models.collectibles.visible = false;

                    console.log('âœ… 3D ëª¨ë¸ ë¡œë”© ì™„ë£Œ');
                } catch (error) {
                    console.error('âŒ 3D ëª¨ë¸ ë¡œë”© ì‹¤íŒ¨:', error);
                }
            }

            loadModel(loader, url) {
                return new Promise((resolve, reject) => {
                    loader.load(
                        url,
                        (gltf) => resolve(gltf.scene),
                        undefined,
                        (error) => reject(error)
                    );
                });
            }

            // ===== ê²Œì„ í”Œë¡œìš° =====

            async startGame() {
                console.log('ğŸ® ê²Œì„ ì‹œì‘!');

                // ë©”ë‰´ ìˆ¨ê¸°ê¸°
                document.getElementById('menuScreen').classList.add('hidden');

                // ì¹´ìš´íŠ¸ë‹¤ìš´
                await this.countdown();

                // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
                this.state.playing = true;
                this.state.survivalTime = 0;
                this.state.score = 0;
                this.state.distance = 0;
                this.state.starsCollected = 0;
                this.state.coinsCollected = 0;
                this.state.speed = 5;
                this.state.startTime = Date.now();

                // ì§€í˜• ìƒì„±ê¸° ì´ˆê¸°í™”
                this.terrainGenerator = new TerrainGenerator(this);
                this.terrainGenerator.init();

                // êµ¬ìŠ¬ ìœ„ì¹˜ ì´ˆê¸°í™” (ì§€í˜• ìœ„ì— ì•ˆì°©)
                this.ballBody.position.set(0, 0.5, 0);
                this.ballBody.velocity.set(0, 0, 0);
                this.ballBody.angularVelocity.set(0, 0, 0);

                // ê²Œì„ ë£¨í”„ ì‹œì‘
                this.gameLoop();
            }

            async countdown() {
                const counts = ['3', '2', '1', 'GO!'];
                for (const count of counts) {
                    const countdownEl = document.createElement('div');
                    countdownEl.className = 'countdown';
                    countdownEl.textContent = count;
                    document.body.appendChild(countdownEl);

                    await new Promise(resolve => setTimeout(resolve, 1000));
                    countdownEl.remove();
                }
            }

            gameLoop() {
                if (!this.state.playing) return;

                requestAnimationFrame(() => this.gameLoop());

                const deltaTime = this.clock.getDelta();

                // ë¬¼ë¦¬ ì—…ë°ì´íŠ¸
                this.world.step(1 / 60, deltaTime, 3);

                // êµ¬ìŠ¬ ë©”ì‹œ ë™ê¸°í™”
                if (this.ballMesh && this.ballBody) {
                    this.ballMesh.position.copy(this.ballBody.position);
                    this.ballMesh.quaternion.copy(this.ballBody.quaternion);
                }

                // ì¹´ë©”ë¼ ì¶”ì  (ì†ë„ ê¸°ë°˜ ë‹¤ì´ë‚˜ë¯¹ ê±°ë¦¬)
                if (this.ballBody) {
                    const speed = this.ballBody.velocity.length();
                    const baseDist = 10;
                    const speedFactor = Math.min(speed / 20, 1);
                    const targetDist = baseDist + speedFactor * 5;

                    const targetX = this.ballBody.position.x;
                    const targetY = this.ballBody.position.y + 5 + speedFactor * 2;
                    const targetZ = this.ballBody.position.z + targetDist;

                    this.camera.position.x += (targetX - this.camera.position.x) * 0.15;
                    this.camera.position.y += (targetY - this.camera.position.y) * 0.15;
                    this.camera.position.z += (targetZ - this.camera.position.z) * 0.15;

                    this.camera.lookAt(
                        this.ballBody.position.x,
                        this.ballBody.position.y + 1,
                        this.ballBody.position.z
                    );

                    // ì†ë„ê° ê°•ì¡° (FOV ë³€ê²½)
                    const baseFOV = 75;
                    const targetFOV = baseFOV + speedFactor * 10;
                    this.camera.fov += (targetFOV - this.camera.fov) * 0.05;
                    this.camera.updateProjectionMatrix();

                    // ì¡°ëª… ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (êµ¬ìŠ¬ ì¶”ì )
                    if (this.ballLight) {
                        this.ballLight.position.copy(this.ballBody.position);
                        this.ballLight.position.y += 2;
                    }

                    if (this.directionalLight) {
                        this.directionalLight.target.position.copy(this.ballBody.position);
                        this.directionalLight.target.updateMatrixWorld();
                    }
                }

                // ì§€í˜• ì—…ë°ì´íŠ¸
                if (this.terrainGenerator) {
                    this.terrainGenerator.update();
                }

                // ì¶©ëŒ ê²€ì‚¬
                this.checkCollisions();

                // ê²Œì„ ì˜¤ë²„ ì²´í¬
                this.checkGameOver();

                // ìƒì¡´ ì‹œê°„ ì—…ë°ì´íŠ¸
                this.state.survivalTime = (Date.now() - this.state.startTime) / 1000;

                // ê±°ë¦¬ ì—…ë°ì´íŠ¸
                if (this.ballBody) {
                    this.state.distance = Math.max(this.state.distance, Math.abs(this.ballBody.position.z));
                }

                // ë‚œì´ë„ ì¦ê°€ (30ì´ˆë§ˆë‹¤ ì†ë„ ì¦ê°€)
                const difficultyLevel = Math.floor(this.state.survivalTime / 30);
                this.state.speed = 5 + difficultyLevel * 0.5;

                // UI ì—…ë°ì´íŠ¸
                this.updateUI();

                // ë Œë”ë§
                this.renderer.render(this.scene, this.camera);
            }

            checkCollisions() {
                // ì¥ì• ë¬¼ ì¶©ëŒ
                this.obstacles.forEach((obstacle, index) => {
                    if (!obstacle.body || !this.ballBody) return;

                    const distance = this.ballBody.position.distanceTo(obstacle.body.position);
                    if (distance < 1.5) {
                        this.gameOver('ì¥ì• ë¬¼ ì¶©ëŒ!');
                    }
                });

                // ì•„ì´í…œ ìˆ˜ì§‘
                this.items.forEach((item, index) => {
                    if (!item.mesh || !this.ballBody) return;

                    const distance = this.ballBody.position.distanceTo(item.mesh.position);
                    if (distance < 1.0) {
                        this.collectItem(item, index);
                    }
                });
            }

            collectItem(item, index) {
                const type = item.type;

                if (type === 'star') {
                    this.state.starsCollected++;
                    this.state.score += 100;
                    this.showFeedback('+100 â­', '#FFD700');
                } else if (type === 'coin') {
                    this.state.coinsCollected++;
                    this.state.score += 50;
                    this.showFeedback('+50 ğŸ’°', '#FFC700');
                }

                // ì•„ì´í…œ ì œê±°
                this.scene.remove(item.mesh);
                this.items.splice(index, 1);

                // íŒŒí‹°í´ íš¨ê³¼ (ê°„ë‹¨í•œ êµ¬í˜„)
                this.createParticles(item.mesh.position, type === 'star' ? 0xFFD700 : 0xFFC700);
            }

            createParticles(position, color) {
                const particleCount = 50;  // 10 â†’ 50

                // GPU ê¸°ë°˜ íŒŒí‹°í´ (THREE.Points)
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const velocities = [];

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = position.x;
                    positions[i * 3 + 1] = position.y;
                    positions[i * 3 + 2] = position.z;

                    velocities.push({
                        x: (Math.random() - 0.5) * 3,
                        y: Math.random() * 3,
                        z: (Math.random() - 0.5) * 3
                    });
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const material = new THREE.PointsMaterial({
                    color: color,
                    size: 0.15,
                    transparent: true,
                    opacity: 1.0,
                    blending: THREE.AdditiveBlending,  // ë¹›ë‚˜ëŠ” íš¨ê³¼
                    depthWrite: false,
                    sizeAttenuation: true
                });

                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);

                let life = 0;
                const animate = () => {
                    life += 0.01;
                    if (life > 1) {
                        this.scene.remove(particles);
                        geometry.dispose();
                        material.dispose();
                        return;
                    }

                    const posArray = particles.geometry.attributes.position.array;
                    for (let i = 0; i < particleCount; i++) {
                        posArray[i * 3] += velocities[i].x * 0.05;
                        posArray[i * 3 + 1] += velocities[i].y * 0.05 - life * 0.15;  // ì¤‘ë ¥
                        posArray[i * 3 + 2] += velocities[i].z * 0.05;
                    }
                    particles.geometry.attributes.position.needsUpdate = true;

                    material.opacity = 1 - life;
                    material.size = 0.15 * (1 + life);  // í¬ê¸° ì¦ê°€

                    requestAnimationFrame(animate);
                };
                animate();
            }

            checkGameOver() {
                if (!this.ballBody) return;

                // ë‚™í•˜ ê°ì§€
                if (this.ballBody.position.y < -10) {
                    this.gameOver('ë§µ ì´íƒˆ!');
                }
            }

            gameOver(reason) {
                if (!this.state.playing) return;

                console.log('ğŸ’€ ê²Œì„ ì˜¤ë²„:', reason);
                this.state.playing = false;

                // ì ìˆ˜ ê³„ì‚°
                const finalScore = this.calculateScore();

                // ë­í‚¹ ì €ì¥
                this.saveRanking(finalScore);

                // ê²°ê³¼ í™”ë©´ í‘œì‹œ
                this.showResults(finalScore);
            }

            calculateScore() {
                const timeBonus = Math.floor(this.state.survivalTime * 10);
                const distanceBonus = Math.floor(this.state.distance);
                const starBonus = this.state.starsCollected * 100;
                const coinBonus = this.state.coinsCollected * 50;

                const totalScore = timeBonus + distanceBonus + starBonus + coinBonus;

                return {
                    totalScore,
                    timeBonus,
                    distanceBonus,
                    starBonus,
                    coinBonus,
                    survivalTime: this.state.survivalTime.toFixed(1),
                    stars: this.state.starsCollected,
                    coins: this.state.coinsCollected,
                    distance: this.state.distance.toFixed(1)
                };
            }

            saveRanking(scoreData) {
                const ranking = {
                    score: scoreData.totalScore,
                    time: scoreData.survivalTime,
                    stars: scoreData.stars,
                    coins: scoreData.coins,
                    distance: scoreData.distance,
                    timestamp: Date.now()
                };

                // LocalStorageì— ì €ì¥
                let rankings = JSON.parse(localStorage.getItem('mmm-rankings') || '[]');
                rankings.push(ranking);
                rankings.sort((a, b) => b.score - a.score);
                rankings = rankings.slice(0, 10);  // Top 10ë§Œ ìœ ì§€
                localStorage.setItem('mmm-rankings', JSON.stringify(rankings));

                this.currentRankings = rankings;
            }

            showResults(scoreData) {
                document.getElementById('finalTime').textContent = scoreData.survivalTime;
                document.getElementById('finalScore').textContent = scoreData.totalScore;
                document.getElementById('timeBonus').textContent = scoreData.timeBonus + 'ì ';
                document.getElementById('distanceBonus').textContent = scoreData.distanceBonus + 'ì ';
                document.getElementById('starBonus').textContent = scoreData.starBonus + 'ì ';
                document.getElementById('coinBonus').textContent = scoreData.coinBonus + 'ì ';

                // ë­í‚¹ í‘œì‹œ
                const rankingList = document.getElementById('rankingList');
                rankingList.innerHTML = '';

                this.currentRankings.forEach((rank, index) => {
                    const item = document.createElement('div');
                    item.className = 'ranking-item';
                    if (rank.timestamp === scoreData.timestamp) {
                        item.classList.add('me');
                    }

                    item.innerHTML = `
                        <span class="rank-number">#${index + 1}</span>
                        <span>${rank.score}ì </span>
                        <span>${rank.time}ì´ˆ</span>
                        <span>â­${rank.stars} ğŸ’°${rank.coins}</span>
                    `;
                    rankingList.appendChild(item);
                });

                document.getElementById('resultScreen').classList.add('show');
            }

            showFeedback(text, color) {
                const feedback = document.createElement('div');
                feedback.className = 'feedback-text';
                feedback.textContent = text;
                feedback.style.color = color;
                document.body.appendChild(feedback);

                setTimeout(() => feedback.remove(), 1000);
            }

            updateUI() {
                document.getElementById('timeText').textContent = this.state.survivalTime.toFixed(1);
                document.getElementById('scoreText').textContent = this.state.score;
                document.getElementById('distanceText').textContent = Math.floor(this.state.distance);
                document.getElementById('starsText').textContent = this.state.starsCollected;
                document.getElementById('coinsText').textContent = this.state.coinsCollected;

                // ì†ë„ê³„ ì—…ë°ì´íŠ¸
                if (this.ballBody) {
                    const speed = this.ballBody.velocity.length();
                    document.getElementById('speedText').textContent = speed.toFixed(1);
                }

                // ê¸°ìš¸ê¸° ì¸ë””ì¼€ì´í„° ì—…ë°ì´íŠ¸
                if (this.sensorData && this.sensorData.orientation) {
                    const gamma = this.sensorData.orientation.gamma || 0;
                    const beta = this.sensorData.orientation.beta || 0;

                    const tiltDot = document.getElementById('tiltDot');
                    if (tiltDot) {
                        // -45 ~ 45ë„ë¥¼ -50% ~ 50% ë²”ìœ„ë¡œ ë³€í™˜
                        const maxAngle = 45;
                        const offsetX = (Math.max(-maxAngle, Math.min(maxAngle, gamma)) / maxAngle) * 50;
                        const offsetY = (Math.max(-maxAngle, Math.min(maxAngle, beta)) / maxAngle) * 50;

                        tiltDot.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px))`;
                    }
                }
            }

            restart() {
                // ìƒíƒœ ì´ˆê¸°í™”
                this.state.playing = false;
                this.state.survivalTime = 0;
                this.state.score = 0;
                this.state.distance = 0;
                this.state.starsCollected = 0;
                this.state.coinsCollected = 0;

                // êµ¬ìŠ¬ ìœ„ì¹˜ ì´ˆê¸°í™”
                if (this.ballBody) {
                    this.ballBody.position.set(0, 2, 0);
                    this.ballBody.velocity.set(0, 0, 0);
                    this.ballBody.angularVelocity.set(0, 0, 0);
                }

                // ì§€í˜• ì´ˆê¸°í™”
                if (this.terrainGenerator) {
                    this.terrainGenerator.clear();
                }

                // UI ì´ˆê¸°í™”
                document.getElementById('resultScreen').classList.remove('show');
                document.getElementById('menuScreen').classList.remove('hidden');
                document.getElementById('qrContainer').classList.remove('show');

                this.updateUI();
            }

            onResize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                if (this.camera) {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                }

                if (this.renderer) {
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                }
            }
        }

        // ===== ì§€í˜• ìƒì„±ê¸° =====
        class TerrainGenerator {
            constructor(game) {
                this.game = game;
                this.chunkSize = 10;
                this.chunks = [];
                this.lastChunkZ = 5;  // êµ¬ìŠ¬ ì•ìª½ë¶€í„° ì‹œì‘
                this.obstacleTypes = ['rock', 'tree'];
                this.itemTypes = ['star', 'coin'];
            }

            init() {
                // ì´ˆê¸° ì§€í˜• ìƒì„± (êµ¬ìŠ¬ ì£¼ë³€)
                for (let i = 0; i < 5; i++) {
                    this.generateChunk(this.lastChunkZ);
                    this.lastChunkZ -= this.chunkSize;
                }
            }

            generateChunk(zPosition) {
                // í‰ì§€ íƒ€ì¼ ìƒì„± (ê°„ë‹¨í•œ êµ¬í˜„)
                const geometry = new THREE.BoxGeometry(20, 0.2, this.chunkSize);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x44CC44,
                    roughness: 0.8
                });

                const tile = new THREE.Mesh(geometry, material);
                tile.position.set(0, 0, zPosition);  // y=0ìœ¼ë¡œ ë³€ê²½
                tile.receiveShadow = true;
                this.game.scene.add(tile);

                // ë¬¼ë¦¬ ë°”ë””
                const shape = new CANNON.Box(new CANNON.Vec3(10, 0.1, this.chunkSize / 2));
                const body = new CANNON.Body({
                    mass: 0,
                    shape: shape,
                    position: new CANNON.Vec3(0, 0, zPosition)  // y=0ìœ¼ë¡œ ë³€ê²½
                });
                this.game.world.addBody(body);

                const chunk = { mesh: tile, body: body, z: zPosition };
                this.chunks.push(chunk);

                // ì¥ì• ë¬¼ ë°°ì¹˜
                this.placeObstacles(zPosition);

                // ì•„ì´í…œ ë°°ì¹˜
                this.placeItems(zPosition);
            }

            placeObstacles(zPosition) {
                const difficulty = Math.floor(this.game.state.survivalTime / 30);
                const obstacleCount = 2 + difficulty;

                for (let i = 0; i < obstacleCount; i++) {
                    if (Math.random() > 0.5) {  // 50% í™•ë¥ 
                        const type = this.obstacleTypes[Math.floor(Math.random() * this.obstacleTypes.length)];
                        this.createObstacle(type, zPosition);
                    }
                }
            }

            createObstacle(type, zPosition) {
                if (!this.game.models.obstacles) return;

                let obstacleModel;
                const x = (Math.random() - 0.5) * 16;
                const z = zPosition + (Math.random() - 0.5) * this.chunkSize;

                if (type === 'rock') {
                    // GLBì—ì„œ ë°”ìœ„ ë©”ì‹œ ë³µì œ
                    const rockOriginal = this.game.models.obstacles.getObjectByName('Rock');
                    if (rockOriginal) {
                        obstacleModel = rockOriginal.clone();
                        obstacleModel.scale.set(1.5, 1.5, 1.5);
                        obstacleModel.position.set(x, 0.5, z);

                        // ì¬ì§ˆ ì—…ê·¸ë ˆì´ë“œ
                        obstacleModel.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                if (child.material) {
                                    child.material.roughness = 0.9;
                                }
                            }
                        });

                        this.game.scene.add(obstacleModel);

                        // ë¬¼ë¦¬ ë°”ë”” (êµ¬ í˜•íƒœ)
                        const shape = new CANNON.Sphere(1.2);
                        const body = new CANNON.Body({
                            mass: 0,
                            shape: shape,
                            position: new CANNON.Vec3(x, 0.5, z)
                        });
                        this.game.world.addBody(body);

                        this.game.obstacles.push({ mesh: obstacleModel, body: body, type: 'rock' });
                    }
                } else if (type === 'tree') {
                    // GLBì—ì„œ ë‚˜ë¬´ ë©”ì‹œ ë³µì œ
                    const treeGroup = new THREE.Group();

                    const trunkOriginal = this.game.models.obstacles.getObjectByName('Tree_Trunk');
                    const leavesOriginal = this.game.models.obstacles.getObjectByName('Tree_Leaves');

                    if (trunkOriginal && leavesOriginal) {
                        const trunk = trunkOriginal.clone();
                        const leaves = leavesOriginal.clone();

                        trunk.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });

                        leaves.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });

                        treeGroup.add(trunk);
                        treeGroup.add(leaves);
                        treeGroup.scale.set(2, 2, 2);
                        treeGroup.position.set(x, 0, z);

                        this.game.scene.add(treeGroup);

                        // ë¬¼ë¦¬ ë°”ë”” (ì›ê¸°ë‘¥)
                        const shape = new CANNON.Cylinder(0.6, 0.6, 3, 8);
                        const body = new CANNON.Body({
                            mass: 0,
                            shape: shape,
                            position: new CANNON.Vec3(x, 1.5, z)
                        });
                        this.game.world.addBody(body);

                        this.game.obstacles.push({ mesh: treeGroup, body: body, type: 'tree' });
                    }
                }
            }

            placeItems(zPosition) {
                const itemCount = 5;

                for (let i = 0; i < itemCount; i++) {
                    const type = Math.random() > 0.5 ? 'star' : 'coin';
                    this.createItem(type, zPosition);
                }
            }

            createItem(type, zPosition) {
                if (!this.game.models.collectibles) return;

                let itemModel;
                const x = (Math.random() - 0.5) * 16;
                const y = 0.5;
                const z = zPosition + (Math.random() - 0.5) * this.chunkSize;

                if (type === 'star') {
                    // GLBì—ì„œ ë³„ ë©”ì‹œ ë³µì œ
                    const starOriginal = this.game.models.collectibles.getObjectByName('Star');
                    if (starOriginal) {
                        itemModel = starOriginal.clone();
                        itemModel.scale.set(0.8, 0.8, 0.8);
                        itemModel.position.set(x, y, z);

                        // ë°œê´‘ íš¨ê³¼ ê°•í™”
                        itemModel.traverse((child) => {
                            if (child.isMesh && child.material) {
                                child.material.emissive = new THREE.Color(0xFFD700);
                                child.material.emissiveIntensity = 2.0;
                                child.material.metalness = 0.3;
                                child.material.roughness = 0.4;
                            }
                        });
                    }
                } else {
                    // GLBì—ì„œ ì½”ì¸ ë©”ì‹œ ë³µì œ
                    const coinOriginal = this.game.models.collectibles.getObjectByName('Coin');
                    if (coinOriginal) {
                        itemModel = coinOriginal.clone();
                        itemModel.scale.set(0.6, 0.6, 0.6);
                        itemModel.position.set(x, y, z);

                        // ë©”íƒˆë¦­ ì¬ì§ˆ ê°•í™”
                        itemModel.traverse((child) => {
                            if (child.isMesh && child.material) {
                                child.material.metalness = 0.9;
                                child.material.roughness = 0.2;
                                child.material.color = new THREE.Color(0xFFD700);
                            }
                        });
                    }
                }

                if (!itemModel) return;

                this.game.scene.add(itemModel);

                // íšŒì „ ì• ë‹ˆë©”ì´ì…˜
                itemModel.userData.rotationSpeed = Math.random() * 0.03 + 0.03;
                const animate = () => {
                    if (!this.game.state.playing) return;
                    itemModel.rotation.y += itemModel.userData.rotationSpeed;
                    // ìœ„ì•„ë˜ë¡œ ë– ë‹¤ë‹ˆëŠ” íš¨ê³¼
                    itemModel.position.y = y + Math.sin(Date.now() * 0.002 + x) * 0.1;
                    requestAnimationFrame(animate);
                };
                animate();

                this.game.items.push({ mesh: itemModel, type: type });
            }

            update() {
                if (!this.game.ballBody) return;

                const ballZ = this.game.ballBody.position.z;

                // ìƒˆ ì²­í¬ ìƒì„± (êµ¬ìŠ¬ ì•ì—)
                if (ballZ - 30 < this.lastChunkZ) {
                    this.generateChunk(this.lastChunkZ);
                    this.lastChunkZ -= this.chunkSize;
                }

                // ì˜¤ë˜ëœ ì²­í¬ ì œê±°
                this.chunks = this.chunks.filter(chunk => {
                    if (chunk.z > ballZ + 20) {
                        this.game.scene.remove(chunk.mesh);
                        this.game.world.removeBody(chunk.body);
                        return false;
                    }
                    return true;
                });

                // ì˜¤ë˜ëœ ì¥ì• ë¬¼ ì œê±°
                this.game.obstacles = this.game.obstacles.filter(obstacle => {
                    if (obstacle.body.position.z > ballZ + 20) {
                        this.game.scene.remove(obstacle.mesh);
                        this.game.world.removeBody(obstacle.body);
                        return false;
                    }
                    return true;
                });

                // ì˜¤ë˜ëœ ì•„ì´í…œ ì œê±°
                this.game.items = this.game.items.filter(item => {
                    if (item.mesh.position.z > ballZ + 20) {
                        this.game.scene.remove(item.mesh);
                        return false;
                    }
                    return true;
                });
            }

            clear() {
                // ëª¨ë“  ì²­í¬ ì œê±°
                this.chunks.forEach(chunk => {
                    this.game.scene.remove(chunk.mesh);
                    this.game.world.removeBody(chunk.body);
                });
                this.chunks = [];

                // ëª¨ë“  ì¥ì• ë¬¼ ì œê±°
                this.game.obstacles.forEach(obstacle => {
                    this.game.scene.remove(obstacle.mesh);
                    this.game.world.removeBody(obstacle.body);
                });
                this.game.obstacles = [];

                // ëª¨ë“  ì•„ì´í…œ ì œê±°
                this.game.items.forEach(item => {
                    this.game.scene.remove(item.mesh);
                });
                this.game.items = [];

                this.lastChunkZ = -20;
            }
        }

        // ê²Œì„ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
        const game = new MountainMarbleMaze();

        console.log('ğŸ”ï¸ Mountain Marble Maze ë¡œë“œ ì™„ë£Œ!');
    </script>
</body>
</html>
