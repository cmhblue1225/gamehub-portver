<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mountain Marble Maze - 3D ì„¼ì„œ ê²Œì„</title>

    <!-- Socket.IO -->
    <script src="/socket.io/socket.io.js"></script>

    <!-- QR Code -->
    <script src="https://unpkg.com/qrcode@1.5.3/build/qrcode.min.js"></script>

    <!-- SessionSDK -->
    <script src="/js/SessionSDK.js"></script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <!-- Cannon.js (ë¬¼ë¦¬ ì—”ì§„) -->
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', 'Malgun Gothic', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
            background: linear-gradient(180deg, #87CEEB 0%, #E0F6FF 50%, #90EE90 100%);
        }

        /* UI ì˜¤ë²„ë ˆì´ */
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .ui-overlay > * {
            pointer-events: auto;
        }

        /* ìƒë‹¨ HUD */
        .top-hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .hud-item {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            margin: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .hud-time {
            background: rgba(255, 100, 100, 0.9);
        }

        .hud-score {
            background: rgba(255, 215, 0, 0.9);
            color: #333;
        }

        .hud-distance {
            background: rgba(76, 175, 80, 0.9);
        }

        /* í•˜ë‹¨ ì•„ì´í…œ ìƒíƒœ */
        .bottom-hud {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 15px;
        }

        .item-count {
            color: #fff;
            font-size: 24px;
            font-weight: bold;
        }

        .item-count .icon {
            margin-right: 5px;
        }

        /* ë©”ë‰´ í™”ë©´ */
        .menu-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .menu-screen.hidden {
            display: none;
        }

        .menu-title {
            font-size: 64px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.5);
            margin-bottom: 20px;
            animation: bounce 1s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .menu-subtitle {
            font-size: 24px;
            color: #fff;
            margin-bottom: 40px;
            text-align: center;
            padding: 0 20px;
        }

        .start-btn {
            padding: 20px 60px;
            font-size: 28px;
            font-weight: bold;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 30px;
        }

        .start-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 30px rgba(76, 175, 80, 0.5);
        }

        /* QR ì½”ë“œ ì»¨í…Œì´ë„ˆ */
        .qr-container {
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            text-align: center;
            display: none;
        }

        .qr-container.show {
            display: block;
        }

        .qr-title {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
        }

        .session-code {
            font-size: 32px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 15px;
            letter-spacing: 5px;
        }

        /* ê²°ê³¼ í™”ë©´ */
        .result-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
        }

        .result-screen.show {
            display: flex;
        }

        .result-title {
            font-size: 64px;
            font-weight: bold;
            color: #FF6B6B;
            margin-bottom: 20px;
        }

        .survival-time {
            font-size: 48px;
            color: #4ECDC4;
            margin-bottom: 30px;
        }

        .final-score {
            font-size: 56px;
            color: #FFD700;
            margin-bottom: 20px;
        }

        .score-breakdown {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            width: 100%;
            max-width: 500px;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            color: #fff;
            font-size: 20px;
            margin: 10px 0;
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .ranking-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            width: 100%;
            max-width: 600px;
        }

        .ranking-title {
            font-size: 32px;
            color: #FFD700;
            margin-bottom: 15px;
            text-align: center;
        }

        .ranking-list {
            color: #fff;
        }

        .ranking-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-size: 18px;
        }

        .ranking-item.me {
            background: rgba(76, 175, 80, 0.3);
            border: 2px solid #4CAF50;
        }

        .rank-number {
            font-weight: bold;
            color: #FFD700;
            min-width: 40px;
        }

        .restart-btn {
            padding: 20px 60px;
            font-size: 28px;
            font-weight: bold;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .restart-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 30px rgba(76, 175, 80, 0.5);
        }

        /* í”¼ë“œë°± í…ìŠ¤íŠ¸ */
        .feedback-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
            animation: fadeOut 1s;
            pointer-events: none;
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        /* ì¹´ìš´íŠ¸ë‹¤ìš´ */
        .countdown {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 5px 5px 10px rgba(0,0,0,0.5);
            z-index: 500;
            animation: pulse 0.5s;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>
    <!-- ë©”ë‰´ í™”ë©´ -->
    <div class="menu-screen" id="menuScreen">
        <div class="menu-title">ğŸ”ï¸ Mountain Marble Maze</div>
        <div class="menu-subtitle">
            ê¸°ìš¸ì—¬ì„œ ì¡°ì‘í•˜ëŠ” 3D ë¬´í•œ ìƒì¡´ ê²Œì„!<br>
            ì¥ì• ë¬¼ì„ í”¼í•˜ê³  ì•„ì´í…œì„ ìˆ˜ì§‘í•˜ì„¸ìš”
        </div>

        <button class="start-btn" onclick="game.init()">ğŸ® ê²Œì„ ì‹œì‘</button>

        <div class="qr-container" id="qrContainer">
            <div class="qr-title">ğŸ“± í•¸ë“œí°ìœ¼ë¡œ QR ì½”ë“œë¥¼ ìŠ¤ìº”í•˜ì„¸ìš”</div>
            <div class="session-code" id="sessionCode">------</div>
            <div id="qrCode"></div>
            <div style="margin-top: 20px; color: #666;">
                ì„¼ì„œê°€ ì—°ê²°ë˜ë©´ ìë™ìœ¼ë¡œ ê²Œì„ì´ ì‹œì‘ë©ë‹ˆë‹¤
            </div>
        </div>
    </div>

    <!-- ê²Œì„ ìº”ë²„ìŠ¤ -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI ì˜¤ë²„ë ˆì´ -->
    <div class="ui-overlay">
        <div class="top-hud">
            <div class="hud-item hud-time">â±ï¸ <span id="timeText">0.0</span>ì´ˆ</div>
            <div class="hud-item hud-score">ğŸ† <span id="scoreText">0</span>ì </div>
            <div class="hud-item hud-distance">ğŸ“ <span id="distanceText">0</span>m</div>
        </div>

        <div class="bottom-hud">
            <div class="item-count">
                <span class="icon">â­</span>
                <span id="starsText">0</span>
            </div>
            <div class="item-count">
                <span class="icon">ğŸ’°</span>
                <span id="coinsText">0</span>
            </div>
        </div>
    </div>

    <!-- ê²°ê³¼ í™”ë©´ -->
    <div class="result-screen" id="resultScreen">
        <div class="result-title">Game Over!</div>
        <div class="survival-time">ìƒì¡´ ì‹œê°„: <span id="finalTime">0</span>ì´ˆ</div>
        <div class="final-score">ìµœì¢… ì ìˆ˜: <span id="finalScore">0</span>ì </div>

        <div class="score-breakdown">
            <div class="score-item">
                <span>ìƒì¡´ ì‹œê°„</span>
                <span id="timeBonus">0ì </span>
            </div>
            <div class="score-item">
                <span>ì´ë™ ê±°ë¦¬</span>
                <span id="distanceBonus">0ì </span>
            </div>
            <div class="score-item">
                <span>â­ ë³„ ìˆ˜ì§‘</span>
                <span id="starBonus">0ì </span>
            </div>
            <div class="score-item">
                <span>ğŸ’° ì½”ì¸ ìˆ˜ì§‘</span>
                <span id="coinBonus">0ì </span>
            </div>
        </div>

        <div class="ranking-section">
            <div class="ranking-title">ğŸ† Top 10 Ranking</div>
            <div class="ranking-list" id="rankingList"></div>
        </div>

        <button class="restart-btn" onclick="game.restart()">ğŸ”„ ë‹¤ì‹œ í•˜ê¸°</button>
    </div>

    <script>
        // ===== ë©”ì¸ ê²Œì„ í´ë˜ìŠ¤ =====
        class MountainMarbleMaze {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                // SDK ì´ˆê¸°í™”
                this.sdk = new SessionSDK({
                    gameId: 'mountain-marble-maze',
                    gameType: 'solo',
                    debug: true
                });

                // ê²Œì„ ìƒíƒœ
                this.state = {
                    connected: false,
                    playing: false,
                    paused: false,
                    survivalTime: 0,
                    score: 0,
                    distance: 0,
                    starsCollected: 0,
                    coinsCollected: 0,
                    speed: 5,  // ì§„í–‰ ì†ë„
                    startTime: 0
                };

                // 3D ì‹œìŠ¤í…œ
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.clock = new THREE.Clock();

                // ë¬¼ë¦¬ ì‹œìŠ¤í…œ
                this.world = null;
                this.ballBody = null;
                this.ballMesh = null;

                // ì§€í˜• ì‹œìŠ¤í…œ
                this.terrainGenerator = null;
                this.chunks = [];
                this.obstacles = [];
                this.items = [];

                // 3D ëª¨ë¸
                this.models = {
                    marble: null,
                    terrainTiles: null,
                    obstacles: null,
                    collectibles: null
                };

                // ì„¼ì„œ ë°ì´í„°
                this.sensorData = null;
                this.forceMultiplier = 30;

                // ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ëŸ¬
                window.addEventListener('resize', () => this.onResize());
            }

            async init() {
                console.log('ğŸ® ê²Œì„ ì´ˆê¸°í™” ì‹œì‘...');

                // SDK ì´ë²¤íŠ¸ ì„¤ì •
                this.setupSDK();

                // 3D ì´ˆê¸°í™”
                this.init3D();

                // ë¬¼ë¦¬ ì´ˆê¸°í™”
                this.initPhysics();

                // 3D ëª¨ë¸ ë¡œë”©
                await this.loadModels();

                // QR ì»¨í…Œì´ë„ˆ í‘œì‹œ
                document.getElementById('qrContainer').classList.add('show');

                // ì„¸ì…˜ ìƒì„±
                await this.sdk.createSession();
            }

            setupSDK() {
                // ì„œë²„ ì—°ê²°
                this.sdk.on('connected', () => {
                    console.log('âœ… ì„œë²„ ì—°ê²° ì™„ë£Œ');
                    this.state.connected = true;
                });

                // ì„¸ì…˜ ìƒì„±
                this.sdk.on('session-created', (event) => {
                    const session = event.detail || event;
                    console.log('âœ… ì„¸ì…˜ ìƒì„±:', session.sessionCode);

                    document.getElementById('sessionCode').textContent = session.sessionCode;

                    // QR ì½”ë“œ ìƒì„±
                    const sensorUrl = `${window.location.origin}/sensor.html?session=${session.sessionCode}`;
                    QRCodeGenerator.generateElement(sensorUrl, 200)
                        .then(qrElement => {
                            const container = document.getElementById('qrCode');
                            container.innerHTML = '';
                            container.appendChild(qrElement);
                        })
                        .catch(err => {
                            console.error('QR ì½”ë“œ ìƒì„± ì‹¤íŒ¨:', err);
                        });
                });

                // ì„¼ì„œ ì—°ê²°
                this.sdk.on('sensor-connected', (event) => {
                    console.log('ğŸ“± ì„¼ì„œ ì—°ê²°ë¨');
                    setTimeout(() => this.startGame(), 1000);
                });

                // ì„¼ì„œ ë°ì´í„° ìˆ˜ì‹ 
                this.sdk.on('sensor-data', (event) => {
                    const data = event.detail || event;
                    this.processSensorData(data);
                });
            }

            processSensorData(sensorData) {
                if (!sensorData || !sensorData.data || !this.state.playing) return;

                this.sensorData = sensorData.data;

                // ê¸°ìš¸ê¸° â†’ ë¬¼ë¦¬ë ¥ ë³€í™˜
                if (this.sensorData.orientation && this.ballBody) {
                    const gamma = this.sensorData.orientation.gamma || 0;  // ì¢Œìš°
                    const beta = this.sensorData.orientation.beta || 0;    // ì „í›„

                    // ê°ë„ â†’ í˜ (ì‚¼ê°í•¨ìˆ˜)
                    const forceX = Math.sin(gamma * Math.PI / 180) * this.forceMultiplier;
                    const forceZ = Math.sin(beta * Math.PI / 180) * this.forceMultiplier;

                    // ë¬¼ë¦¬ ì—”ì§„ì— í˜ ì ìš©
                    const force = new CANNON.Vec3(forceX, 0, forceZ);
                    const worldPoint = new CANNON.Vec3(
                        this.ballBody.position.x,
                        this.ballBody.position.y,
                        this.ballBody.position.z
                    );
                    this.ballBody.applyForce(force, worldPoint);
                }
            }

            // ===== 3D ì‹œìŠ¤í…œ =====

            init3D() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

                // Camera (3ì¸ì¹­ ì¶”ì )
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 5, 10);
                this.camera.lookAt(0, 0, 0);

                // Renderer
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    antialias: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // ì¡°ëª…
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 100;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                this.scene.add(directionalLight);

                const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x90EE90, 0.6);
                this.scene.add(hemisphereLight);

                console.log('âœ… 3D ì—”ì§„ ì´ˆê¸°í™” ì™„ë£Œ');
            }

            initPhysics() {
                // Cannon.js ì›”ë“œ
                this.world = new CANNON.World();
                this.world.gravity.set(0, -9.82, 0);
                this.world.broadphase = new CANNON.NaiveBroadphase();
                this.world.solver.iterations = 10;

                // ì¬ì§ˆ
                const ballMaterial = new CANNON.Material('ball');
                const groundMaterial = new CANNON.Material('ground');

                const contactMaterial = new CANNON.ContactMaterial(
                    ballMaterial,
                    groundMaterial,
                    {
                        friction: 0.3,
                        restitution: 0.6
                    }
                );
                this.world.addContactMaterial(contactMaterial);

                // êµ¬ìŠ¬ ë¬¼ë¦¬ ë°”ë””
                const ballShape = new CANNON.Sphere(0.5);
                this.ballBody = new CANNON.Body({
                    mass: 1,
                    shape: ballShape,
                    material: ballMaterial,
                    position: new CANNON.Vec3(0, 2, 0),
                    linearDamping: 0.3,
                    angularDamping: 0.3
                });
                this.world.addBody(this.ballBody);

                console.log('âœ… ë¬¼ë¦¬ ì—”ì§„ ì´ˆê¸°í™” ì™„ë£Œ');
            }

            async loadModels() {
                const loader = new THREE.GLTFLoader();
                console.log('ğŸ“¦ 3D ëª¨ë¸ ë¡œë”© ì¤‘...');

                try {
                    // êµ¬ìŠ¬
                    const marble = await this.loadModel(loader, 'assets/models/marble-ball.glb');
                    marble.scale.set(1, 1, 1);
                    marble.castShadow = true;
                    marble.receiveShadow = true;
                    this.scene.add(marble);
                    this.ballMesh = marble;
                    this.models.marble = marble;

                    // ì§€í˜• íƒ€ì¼ (ë‚˜ì¤‘ì— ì‚¬ìš©)
                    this.models.terrainTiles = await this.loadModel(loader, 'assets/models/terrain-tiles.glb');
                    this.models.terrainTiles.visible = false;

                    // ì¥ì• ë¬¼
                    this.models.obstacles = await this.loadModel(loader, 'assets/models/obstacles.glb');
                    this.models.obstacles.visible = false;

                    // ì•„ì´í…œ
                    this.models.collectibles = await this.loadModel(loader, 'assets/models/collectibles.glb');
                    this.models.collectibles.visible = false;

                    console.log('âœ… 3D ëª¨ë¸ ë¡œë”© ì™„ë£Œ');
                } catch (error) {
                    console.error('âŒ 3D ëª¨ë¸ ë¡œë”© ì‹¤íŒ¨:', error);
                }
            }

            loadModel(loader, url) {
                return new Promise((resolve, reject) => {
                    loader.load(
                        url,
                        (gltf) => resolve(gltf.scene),
                        undefined,
                        (error) => reject(error)
                    );
                });
            }

            // ===== ê²Œì„ í”Œë¡œìš° =====

            async startGame() {
                console.log('ğŸ® ê²Œì„ ì‹œì‘!');

                // ë©”ë‰´ ìˆ¨ê¸°ê¸°
                document.getElementById('menuScreen').classList.add('hidden');

                // ì¹´ìš´íŠ¸ë‹¤ìš´
                await this.countdown();

                // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
                this.state.playing = true;
                this.state.survivalTime = 0;
                this.state.score = 0;
                this.state.distance = 0;
                this.state.starsCollected = 0;
                this.state.coinsCollected = 0;
                this.state.speed = 5;
                this.state.startTime = Date.now();

                // ì§€í˜• ìƒì„±ê¸° ì´ˆê¸°í™”
                this.terrainGenerator = new TerrainGenerator(this);
                this.terrainGenerator.init();

                // ê²Œì„ ë£¨í”„ ì‹œì‘
                this.gameLoop();
            }

            async countdown() {
                const counts = ['3', '2', '1', 'GO!'];
                for (const count of counts) {
                    const countdownEl = document.createElement('div');
                    countdownEl.className = 'countdown';
                    countdownEl.textContent = count;
                    document.body.appendChild(countdownEl);

                    await new Promise(resolve => setTimeout(resolve, 1000));
                    countdownEl.remove();
                }
            }

            gameLoop() {
                if (!this.state.playing) return;

                requestAnimationFrame(() => this.gameLoop());

                const deltaTime = this.clock.getDelta();

                // ë¬¼ë¦¬ ì—…ë°ì´íŠ¸
                this.world.step(1 / 60, deltaTime, 3);

                // êµ¬ìŠ¬ ë©”ì‹œ ë™ê¸°í™”
                if (this.ballMesh && this.ballBody) {
                    this.ballMesh.position.copy(this.ballBody.position);
                    this.ballMesh.quaternion.copy(this.ballBody.quaternion);
                }

                // ì¹´ë©”ë¼ ì¶”ì  (ë¶€ë“œëŸ¬ìš´ ì´ë™)
                if (this.ballBody) {
                    const targetX = this.ballBody.position.x;
                    const targetY = this.ballBody.position.y + 5;
                    const targetZ = this.ballBody.position.z + 10;

                    this.camera.position.x += (targetX - this.camera.position.x) * 0.1;
                    this.camera.position.y += (targetY - this.camera.position.y) * 0.1;
                    this.camera.position.z += (targetZ - this.camera.position.z) * 0.1;

                    this.camera.lookAt(this.ballBody.position.x, this.ballBody.position.y, this.ballBody.position.z);
                }

                // ì§€í˜• ì—…ë°ì´íŠ¸
                if (this.terrainGenerator) {
                    this.terrainGenerator.update();
                }

                // ì¶©ëŒ ê²€ì‚¬
                this.checkCollisions();

                // ê²Œì„ ì˜¤ë²„ ì²´í¬
                this.checkGameOver();

                // ìƒì¡´ ì‹œê°„ ì—…ë°ì´íŠ¸
                this.state.survivalTime = (Date.now() - this.state.startTime) / 1000;

                // ê±°ë¦¬ ì—…ë°ì´íŠ¸
                if (this.ballBody) {
                    this.state.distance = Math.max(this.state.distance, Math.abs(this.ballBody.position.z));
                }

                // ë‚œì´ë„ ì¦ê°€ (30ì´ˆë§ˆë‹¤ ì†ë„ ì¦ê°€)
                const difficultyLevel = Math.floor(this.state.survivalTime / 30);
                this.state.speed = 5 + difficultyLevel * 0.5;

                // UI ì—…ë°ì´íŠ¸
                this.updateUI();

                // ë Œë”ë§
                this.renderer.render(this.scene, this.camera);
            }

            checkCollisions() {
                // ì¥ì• ë¬¼ ì¶©ëŒ
                this.obstacles.forEach((obstacle, index) => {
                    if (!obstacle.body || !this.ballBody) return;

                    const distance = this.ballBody.position.distanceTo(obstacle.body.position);
                    if (distance < 1.5) {
                        this.gameOver('ì¥ì• ë¬¼ ì¶©ëŒ!');
                    }
                });

                // ì•„ì´í…œ ìˆ˜ì§‘
                this.items.forEach((item, index) => {
                    if (!item.mesh || !this.ballBody) return;

                    const distance = this.ballBody.position.distanceTo(item.mesh.position);
                    if (distance < 1.0) {
                        this.collectItem(item, index);
                    }
                });
            }

            collectItem(item, index) {
                const type = item.type;

                if (type === 'star') {
                    this.state.starsCollected++;
                    this.state.score += 100;
                    this.showFeedback('+100 â­', '#FFD700');
                } else if (type === 'coin') {
                    this.state.coinsCollected++;
                    this.state.score += 50;
                    this.showFeedback('+50 ğŸ’°', '#FFC700');
                }

                // ì•„ì´í…œ ì œê±°
                this.scene.remove(item.mesh);
                this.items.splice(index, 1);

                // íŒŒí‹°í´ íš¨ê³¼ (ê°„ë‹¨í•œ êµ¬í˜„)
                this.createParticles(item.mesh.position, type === 'star' ? 0xFFD700 : 0xFFC700);
            }

            createParticles(position, color) {
                const particleCount = 10;
                const geometry = new THREE.SphereGeometry(0.05, 4, 4);
                const material = new THREE.MeshBasicMaterial({ color: color });

                for (let i = 0; i < particleCount; i++) {
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.copy(position);
                    this.scene.add(particle);

                    // ëœë¤ ë°©í–¥ìœ¼ë¡œ ë‚ ë¦¬ê¸°
                    const vx = (Math.random() - 0.5) * 2;
                    const vy = Math.random() * 2;
                    const vz = (Math.random() - 0.5) * 2;

                    let life = 0;
                    const animate = () => {
                        life += 0.02;
                        if (life > 1) {
                            this.scene.remove(particle);
                            return;
                        }

                        particle.position.x += vx * 0.05;
                        particle.position.y += vy * 0.05 - life * 0.1;  // ì¤‘ë ¥
                        particle.position.z += vz * 0.05;
                        particle.material.opacity = 1 - life;
                        particle.material.transparent = true;

                        requestAnimationFrame(animate);
                    };
                    animate();
                }
            }

            checkGameOver() {
                if (!this.ballBody) return;

                // ë‚™í•˜ ê°ì§€
                if (this.ballBody.position.y < -10) {
                    this.gameOver('ë§µ ì´íƒˆ!');
                }
            }

            gameOver(reason) {
                if (!this.state.playing) return;

                console.log('ğŸ’€ ê²Œì„ ì˜¤ë²„:', reason);
                this.state.playing = false;

                // ì ìˆ˜ ê³„ì‚°
                const finalScore = this.calculateScore();

                // ë­í‚¹ ì €ì¥
                this.saveRanking(finalScore);

                // ê²°ê³¼ í™”ë©´ í‘œì‹œ
                this.showResults(finalScore);
            }

            calculateScore() {
                const timeBonus = Math.floor(this.state.survivalTime * 10);
                const distanceBonus = Math.floor(this.state.distance);
                const starBonus = this.state.starsCollected * 100;
                const coinBonus = this.state.coinsCollected * 50;

                const totalScore = timeBonus + distanceBonus + starBonus + coinBonus;

                return {
                    totalScore,
                    timeBonus,
                    distanceBonus,
                    starBonus,
                    coinBonus,
                    survivalTime: this.state.survivalTime.toFixed(1),
                    stars: this.state.starsCollected,
                    coins: this.state.coinsCollected,
                    distance: this.state.distance.toFixed(1)
                };
            }

            saveRanking(scoreData) {
                const ranking = {
                    score: scoreData.totalScore,
                    time: scoreData.survivalTime,
                    stars: scoreData.stars,
                    coins: scoreData.coins,
                    distance: scoreData.distance,
                    timestamp: Date.now()
                };

                // LocalStorageì— ì €ì¥
                let rankings = JSON.parse(localStorage.getItem('mmm-rankings') || '[]');
                rankings.push(ranking);
                rankings.sort((a, b) => b.score - a.score);
                rankings = rankings.slice(0, 10);  // Top 10ë§Œ ìœ ì§€
                localStorage.setItem('mmm-rankings', JSON.stringify(rankings));

                this.currentRankings = rankings;
            }

            showResults(scoreData) {
                document.getElementById('finalTime').textContent = scoreData.survivalTime;
                document.getElementById('finalScore').textContent = scoreData.totalScore;
                document.getElementById('timeBonus').textContent = scoreData.timeBonus + 'ì ';
                document.getElementById('distanceBonus').textContent = scoreData.distanceBonus + 'ì ';
                document.getElementById('starBonus').textContent = scoreData.starBonus + 'ì ';
                document.getElementById('coinBonus').textContent = scoreData.coinBonus + 'ì ';

                // ë­í‚¹ í‘œì‹œ
                const rankingList = document.getElementById('rankingList');
                rankingList.innerHTML = '';

                this.currentRankings.forEach((rank, index) => {
                    const item = document.createElement('div');
                    item.className = 'ranking-item';
                    if (rank.timestamp === scoreData.timestamp) {
                        item.classList.add('me');
                    }

                    item.innerHTML = `
                        <span class="rank-number">#${index + 1}</span>
                        <span>${rank.score}ì </span>
                        <span>${rank.time}ì´ˆ</span>
                        <span>â­${rank.stars} ğŸ’°${rank.coins}</span>
                    `;
                    rankingList.appendChild(item);
                });

                document.getElementById('resultScreen').classList.add('show');
            }

            showFeedback(text, color) {
                const feedback = document.createElement('div');
                feedback.className = 'feedback-text';
                feedback.textContent = text;
                feedback.style.color = color;
                document.body.appendChild(feedback);

                setTimeout(() => feedback.remove(), 1000);
            }

            updateUI() {
                document.getElementById('timeText').textContent = this.state.survivalTime.toFixed(1);
                document.getElementById('scoreText').textContent = this.state.score;
                document.getElementById('distanceText').textContent = Math.floor(this.state.distance);
                document.getElementById('starsText').textContent = this.state.starsCollected;
                document.getElementById('coinsText').textContent = this.state.coinsCollected;
            }

            restart() {
                // ìƒíƒœ ì´ˆê¸°í™”
                this.state.playing = false;
                this.state.survivalTime = 0;
                this.state.score = 0;
                this.state.distance = 0;
                this.state.starsCollected = 0;
                this.state.coinsCollected = 0;

                // êµ¬ìŠ¬ ìœ„ì¹˜ ì´ˆê¸°í™”
                if (this.ballBody) {
                    this.ballBody.position.set(0, 2, 0);
                    this.ballBody.velocity.set(0, 0, 0);
                    this.ballBody.angularVelocity.set(0, 0, 0);
                }

                // ì§€í˜• ì´ˆê¸°í™”
                if (this.terrainGenerator) {
                    this.terrainGenerator.clear();
                }

                // UI ì´ˆê¸°í™”
                document.getElementById('resultScreen').classList.remove('show');
                document.getElementById('menuScreen').classList.remove('hidden');
                document.getElementById('qrContainer').classList.remove('show');

                this.updateUI();
            }

            onResize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                if (this.camera) {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                }

                if (this.renderer) {
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                }
            }
        }

        // ===== ì§€í˜• ìƒì„±ê¸° =====
        class TerrainGenerator {
            constructor(game) {
                this.game = game;
                this.chunkSize = 10;
                this.chunks = [];
                this.lastChunkZ = -20;
                this.obstacleTypes = ['rock', 'tree'];
                this.itemTypes = ['star', 'coin'];
            }

            init() {
                // ì´ˆê¸° ì§€í˜• ìƒì„±
                for (let i = 0; i < 5; i++) {
                    this.generateChunk(this.lastChunkZ);
                    this.lastChunkZ -= this.chunkSize;
                }
            }

            generateChunk(zPosition) {
                // í‰ì§€ íƒ€ì¼ ìƒì„± (ê°„ë‹¨í•œ êµ¬í˜„)
                const geometry = new THREE.BoxGeometry(20, 0.2, this.chunkSize);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x44CC44,
                    roughness: 0.8
                });

                const tile = new THREE.Mesh(geometry, material);
                tile.position.set(0, -1, zPosition);
                tile.receiveShadow = true;
                this.game.scene.add(tile);

                // ë¬¼ë¦¬ ë°”ë””
                const shape = new CANNON.Box(new CANNON.Vec3(10, 0.1, this.chunkSize / 2));
                const body = new CANNON.Body({
                    mass: 0,
                    shape: shape,
                    position: new CANNON.Vec3(0, -1, zPosition)
                });
                this.game.world.addBody(body);

                const chunk = { mesh: tile, body: body, z: zPosition };
                this.chunks.push(chunk);

                // ì¥ì• ë¬¼ ë°°ì¹˜
                this.placeObstacles(zPosition);

                // ì•„ì´í…œ ë°°ì¹˜
                this.placeItems(zPosition);
            }

            placeObstacles(zPosition) {
                const difficulty = Math.floor(this.game.state.survivalTime / 30);
                const obstacleCount = 2 + difficulty;

                for (let i = 0; i < obstacleCount; i++) {
                    if (Math.random() > 0.5) {  // 50% í™•ë¥ 
                        const type = this.obstacleTypes[Math.floor(Math.random() * this.obstacleTypes.length)];
                        this.createObstacle(type, zPosition);
                    }
                }
            }

            createObstacle(type, zPosition) {
                let geometry, material;

                if (type === 'rock') {
                    geometry = new THREE.DodecahedronGeometry(1, 0);
                    material = new THREE.MeshStandardMaterial({ color: 0x888888 });
                } else if (type === 'tree') {
                    // ê°„ë‹¨í•œ ë‚˜ë¬´ (ì›ê¸°ë‘¥ + êµ¬)
                    const group = new THREE.Group();

                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.3, 3, 8),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                    );
                    trunk.position.y = 1.5;

                    const leaves = new THREE.Mesh(
                        new THREE.SphereGeometry(1, 8, 8),
                        new THREE.MeshStandardMaterial({ color: 0x55DD55 })
                    );
                    leaves.position.y = 3;

                    group.add(trunk);
                    group.add(leaves);

                    const x = (Math.random() - 0.5) * 16;
                    const z = zPosition + (Math.random() - 0.5) * this.chunkSize;
                    group.position.set(x, 0, z);
                    group.castShadow = true;

                    this.game.scene.add(group);

                    // ë¬¼ë¦¬ ë°”ë””
                    const shape = new CANNON.Cylinder(0.3, 0.3, 3, 8);
                    const body = new CANNON.Body({
                        mass: 0,
                        shape: shape,
                        position: new CANNON.Vec3(x, 1.5, z)
                    });
                    this.game.world.addBody(body);

                    this.game.obstacles.push({ mesh: group, body: body, type: 'tree' });
                    return;
                }

                const mesh = new THREE.Mesh(geometry, material);
                const x = (Math.random() - 0.5) * 16;
                const z = zPosition + (Math.random() - 0.5) * this.chunkSize;
                mesh.position.set(x, 0, z);
                mesh.castShadow = true;

                this.game.scene.add(mesh);

                // ë¬¼ë¦¬ ë°”ë””
                const shape = new CANNON.Sphere(1);
                const body = new CANNON.Body({
                    mass: 0,
                    shape: shape,
                    position: new CANNON.Vec3(x, 0, z)
                });
                this.game.world.addBody(body);

                this.game.obstacles.push({ mesh: mesh, body: body, type: 'rock' });
            }

            placeItems(zPosition) {
                const itemCount = 5;

                for (let i = 0; i < itemCount; i++) {
                    const type = Math.random() > 0.5 ? 'star' : 'coin';
                    this.createItem(type, zPosition);
                }
            }

            createItem(type, zPosition) {
                let geometry, material, color;

                if (type === 'star') {
                    geometry = new THREE.SphereGeometry(0.3, 8, 8);
                    material = new THREE.MeshBasicMaterial({
                        color: 0xFFD700,
                        emissive: 0xFFD700,
                        emissiveIntensity: 0.5
                    });
                    color = 0xFFD700;
                } else {
                    geometry = new THREE.CylinderGeometry(0.25, 0.25, 0.1, 20);
                    material = new THREE.MeshStandardMaterial({
                        color: 0xFFC700,
                        metalness: 0.8,
                        roughness: 0.3
                    });
                    color = 0xFFC700;
                }

                const mesh = new THREE.Mesh(geometry, material);
                const x = (Math.random() - 0.5) * 16;
                const y = 0.5;
                const z = zPosition + (Math.random() - 0.5) * this.chunkSize;
                mesh.position.set(x, y, z);

                this.game.scene.add(mesh);

                // íšŒì „ ì• ë‹ˆë©”ì´ì…˜
                mesh.userData.rotationSpeed = Math.random() * 0.02 + 0.02;
                const animate = () => {
                    if (!this.game.state.playing) return;
                    mesh.rotation.y += mesh.userData.rotationSpeed;
                    requestAnimationFrame(animate);
                };
                animate();

                this.game.items.push({ mesh: mesh, type: type });
            }

            update() {
                if (!this.game.ballBody) return;

                const ballZ = this.game.ballBody.position.z;

                // ìƒˆ ì²­í¬ ìƒì„± (êµ¬ìŠ¬ ì•ì—)
                if (ballZ - 30 < this.lastChunkZ) {
                    this.generateChunk(this.lastChunkZ);
                    this.lastChunkZ -= this.chunkSize;
                }

                // ì˜¤ë˜ëœ ì²­í¬ ì œê±°
                this.chunks = this.chunks.filter(chunk => {
                    if (chunk.z > ballZ + 20) {
                        this.game.scene.remove(chunk.mesh);
                        this.game.world.removeBody(chunk.body);
                        return false;
                    }
                    return true;
                });

                // ì˜¤ë˜ëœ ì¥ì• ë¬¼ ì œê±°
                this.game.obstacles = this.game.obstacles.filter(obstacle => {
                    if (obstacle.body.position.z > ballZ + 20) {
                        this.game.scene.remove(obstacle.mesh);
                        this.game.world.removeBody(obstacle.body);
                        return false;
                    }
                    return true;
                });

                // ì˜¤ë˜ëœ ì•„ì´í…œ ì œê±°
                this.game.items = this.game.items.filter(item => {
                    if (item.mesh.position.z > ballZ + 20) {
                        this.game.scene.remove(item.mesh);
                        return false;
                    }
                    return true;
                });
            }

            clear() {
                // ëª¨ë“  ì²­í¬ ì œê±°
                this.chunks.forEach(chunk => {
                    this.game.scene.remove(chunk.mesh);
                    this.game.world.removeBody(chunk.body);
                });
                this.chunks = [];

                // ëª¨ë“  ì¥ì• ë¬¼ ì œê±°
                this.game.obstacles.forEach(obstacle => {
                    this.game.scene.remove(obstacle.mesh);
                    this.game.world.removeBody(obstacle.body);
                });
                this.game.obstacles = [];

                // ëª¨ë“  ì•„ì´í…œ ì œê±°
                this.game.items.forEach(item => {
                    this.game.scene.remove(item.mesh);
                });
                this.game.items = [];

                this.lastChunkZ = -20;
            }
        }

        // ê²Œì„ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
        const game = new MountainMarbleMaze();

        console.log('ğŸ”ï¸ Mountain Marble Maze ë¡œë“œ ì™„ë£Œ!');
    </script>
</body>
</html>
